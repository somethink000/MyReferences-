#### Что такое ссылки?

> Средство доступа к содержимому одной переменной под разными именами

#### Каковы основные операции с использованием ссылок?

> Есть три основных операции с использованием ссылок: присвоение по ссылке, передача по ссылке и возврат по ссылке.

#### Назовите типы данных, поддерживаемые в РНР.

> Скалярные:
> boolean (логический тип)
> integer (целые числа)
> double (дробные числа)
> string (строки)
> Составные:
> array (массивы)object (объекты)
> Специальные:
> resource (ресурсы)
> null

#### Что такое инкремент и декремент, в чем разница между префиксным и постфиксным инкрементом и декрементом?

   

> Декремент - увеличивает значение переменной на единицу
> Инкремент - уменьшает значение переменной на единицу
> При использовании префиксной нотации сначала происходит изменение переменной, а потом — возврат. При
> использовании постфиксной нотации — наоборот: сначала возврат, а потом изменение переменной.

#### Что такое рекурсия?

>   Функция, которая вызывает саму себя

#### В чем разница между =, == и === ?

>   = - оператор присвоения
>   == - оператор определяет нестрогое сравнение
>   === - оператор строгого сравнение. Эквивалентное сравнение (типы переменных и их значения должны строго совпадать)



#### Какая система типов используется в PHP? Опишите плюсы и минусы.

>   Используется динамическая система типов. Плюсы: в быстрой разработке и прототипировании. Минусы: наличие ошибок
>   и утяжеление дебаггинга.

#### Чем отличаются ключевые слова: mysql_connect и mysql_pconnect?

>   mysql_pconnect() (link is external)работает аналогично mysql_connect() (link is external) с двумя важными отличиями.
>   Во-первых, при соединении функция пытается найти уже открытый (постоянный) указатель на тот же сервер с тем же
>   пользователем и паролем. Если он найден, возвращён функцией будет именно он, вместо открытия нового соединения.
>   Во-вторых, соединение с SQL-сервером не будет закрыто, когда работа скрипта закончится. Вместо этого, оно останется
>   рабочим для будущего использования ( mysql_close() также не закрывает постоянные соединения, открытые
>   mysql_pconnect()).

#### Что такое интерфейсы? Используете ли вы их? Если да — расскажите об этом.

>    Абстарктный тип данных, который определяет контракты по которым обязуются реализовать методы в классах, которые
>    их имплементируют.
>    На практике интерфейсы содержат определения функций (то есть описание их сигнатур) без их реализации.

#### Что такое абстрактный класс и чем он отличается от интерфейса?

>    Интерфейс — это контракт, который должен быть реализован конкретным классом. Абстрактный класс похож на обычный,
>    но отличается тем, что может содержать абстрактные методы — методы без реализации, и нельзя создать экземпляр
>    абстрактного класса. Так же интерфейсы имплементируются, а от абстрактных классов наследуются.

#### Может ли абстрактный класс содержать частный метод?Да
#### Какие модификаторы видимости есть в РНР?
    private, protected, public

#### Какие магические методы вы знаете и как их применяют?
    Магические методы - это специальные методы, которые переопределяют действие PHP по умолчанию, когда над
    объектом выполняются определённые действия.
    construct(), destruct(), call(), callStatic(), get(), set(), isset(), unset(), sleep(), wakeup(), serialize(), unserialize(), toString(),
    invoke(), set_state(), clone() и __debugInfo()

#### Что такое генераторы и как их использовать?
    Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов
    или сложностей, связанных с реализацией класса, реализующего интерфейс Iterator.
    function xrange($start, $limit, $step = 1) {
    if ($start <= $limit) {
    if ($step <= 0) {
    throw new LogicException('Шаг должен быть положительным');
    }
    for ($i = $start                                                                                                                                                                                                                                            ; $i <= $limit ; $i += $step) {
    yield $i                                                                                                                                                                                                                                                    ;
    }
    } else {
    if ($step >= 0) {
    throw new LogicException('Шаг должен быть отрицательным');
    }for ($i = $start                                                                                                                                                                                                                                           ; $i >= $limit ; $i += $step) {
    yield $i                                                                                                                                                                                                                                                    ;
    }
    }
    }
    echo 'Нечётные однозначные числа с помощью range():
    ';
    foreach (range(1, 9, 2) as $number) {
    echo "$number ";
    }
    echo "\n";
    echo 'Нечётные однозначные числа с помощью xrange(): ';
    foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
    }

#### Что делает оператор yield?
    В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо
    прекращения работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при
    следующем вызове функции она возобновит выполнение с места, на котором прервалась.

#### Что такое traits? Альтернативное решение? Приведите пример.
    Трейт - это механизм обеспечения повторного использования кода в языках с поддержкой только одиночного
    наследования, таких как PHP. Трейт предназначен для уменьшения некоторых ограничений одиночного наследования,
    позволяя разработчику повторно использовать наборы методов свободно, в нескольких независимых классах и
    реализованных с использованием разных архитектур построения классов.
    trait Magic{
    // Доступно только внутри трейта
    private $properties                                                                                                                                                                                                                                         ;
    public function __get($key)
    {
    return $this->properties[$key] ?? null                                                                                                                                                                                                                      ;
    }
    public function __set($key, $value)
    {
    $this->properties[$key] = $value                                                                                                                                                                                                                            ;
    }
    }
    class Config
    {
    // Включение трейта в класс
    use Magic                                                                                                                                                                                                                                                   ;
    }
    $config = new Config()                                                                                                                                                                                                                                      ;
    $config->key = 'value';
    echo $config->key                                                                                                                                                                                                                                           ;

#### Опишите поведение при использовании traits с одинаковыми именами полей и / или методов.
    При использовании нескольких трейтов с одинаковыми методами, возникает конфликт. Разрешение конфликта
    производится с помощью оператора insteadOf . Так же если у дочернего класса есть такой же переопределенный метод
    как и у базового, и стаким же именем есть у трейта, порядок вызова следующий:
    Вызов дочернего методаВызов метода трейта
    Вызов у родительского класса
    class Base {
    public function sayHello()
    {
    echo 'Hello ';
    }
    }
    trait SayWorld {
    public function sayHello()
    {
    echo 'SayWorld!';
    }
    }
    trait SayHello {
    public function sayHello()
    {
    echo 'SayWorld!';
    }
    private function saySome()
    {
    echo 'SaySome!';
    }
    }
    class MyHelloWorld extends Base
    {
    use SayWorld, SayHello {SayHello::sayHello insteadOf SayWorld                                                                                                                                                                                               ;
    }
    public function sayForTrait()
    {
    $this->saySome()                                                                                                                                                                                                                                            ;
    }
    }
    $o = new MyHelloWorld()                                                                                                                                                                                                                                     ;
    $o->sayHello()                                                                                                                                                                                                                                              ;
    $o->sayForTrait()                                                                                                                                                                                                                                           ;

#### Будут ли доступны частные методы trait в классе?
    Да

#### Можно ли компоновать traits в trait?
    Да

#### Расскажите об обработке ошибок и исключения (try catch, finaly и throw).
    Исключение в PHP может быть выброшено (throw) и поймано (catch). Код может быть заключён в блок try, чтобы
    облегчить обработку потенциальных исключений. У каждого блока try должен быть как минимум один соответствующий
    блок catch или finally.
    Исключения необходимо для информативного оповещения об ошибке приложения.22. Что такое type hinting, как работает, зачем нужен?
    Type Hinting — это механизм, который позволяет явно указывать типы параметров.

#### Что такое namespace-ы и зачем они нужны?
    Namespace - это механизм использование класса через пространство имен

#### Сравнение значений переменных в РНР и подводные камни? Приведение типов. Что изменилось в
    PHP 8 в этом контексте?
    Есть некотрые особенности привелдения типов таких как:
    string в int , int в bool и так далее. Может зависть от гибкое/жесткое сравнение. Пример:$a = []                                                                                                       ;
    var_dump(empty($a))                                                                                                                                                                                                                                         ;
    var_dump(isset($a))                                                                                                                                                                                                                                         ;
    // Какое значение выведеться в консоли ?
    Таблица сравнений типов в PHP:
    https://www.php.net/manual/ru/types.comparisons.php
    declare(strict_types=1)                                                                                                                                                                                                                                     ;
    PHP8:
    union types
    Типы null и false можно использовать отдельно (возвращаемый тип)
    Возвращаемый тип static
    mixed
    ...

#### Как работает session в РНР, где хранится, как инициализируется?
    Сессии являются простым способом хранения информации для отдельных пользователей с уникальным идентификатором
    сессии. Это может использоваться для сохранения состояния между запросами страниц. Идентификаторы сессий обычно
    отправляются браузеру через сессионный cookie и используются для получения имеющихся данных сессии. Отсутствие
    идентификатора сессии или сессионного cookie сообщает PHP о том, что необходимо создать новую сессию и
    сгенерировать новый идентификатор сессии.
    Создается файл в директории на сервере, который указан в конфигурации php

#### Суперглобальные массивы. Какие знаете? Как использовали?
    $SERVER, $REQUEST, $GET, $POST27. Сравните include vs required, include_once vs required_once.
    include - при отcутствии скрипта в подключенном файле не выдает ошибку, require - выдает. include_once, required_once -
    подключает файл единожды.

#### Что означает сложность алгоритма?
    Сложность алгоритма - это количественная характеристика, которая говорит о том, сколько времени, либо какой объём
    памяти потребуется для выполнения алгоритма. О(n) - обозначается как О большое.

#### Что такое замыкание в PHP? Приведите пример.
    Замыкания в PHP представляют анонимную функцию, которая может использовать переменные из своего локального
    окружения. В отличие от обычных анонимных функций замыкания в PHP могут применять выражение use.
    $a = 8                                                                                                                                                                                                                                                      ;
    $b = 10                                                                                                                                                                                                                                                     ;
    $closure = function($c) use($a, $b)
    {
    return $a + $b + $c                                                                                                                                                                                                                                         ;
    }                                                                                                                                                                                                                                                           ;
    $result = $closure(22)                                                                                                                                                                                                                                      ; // 40
    echo $result                                                                                                                                                                                                                                                ;

#### В чем разница между замыканием в PHP и JavaScrip ?
    В PHP замыкание может быть использовано только с использованием анонимных функций, в то время как в JavaScript
    замыкание может быть создано с помощью любой функции. Кроме того, в JavaScript замыкание может быть использовано
    для создания приватных переменных и методов, что невозможно в PHP.31. Что такое позднее связывание? Расскажите о поведении и применения static.
    PHP реализует функцию, называемую позднее статическое связывание, которая может быть использована для того, чтобы
    получить ссылку на вызываемый класс в контексте статического наследования.
    static::method()
    class A {
    public static function who() {
    print(__CLASS__) . PHP_EOL                                                                                                                                                                                                                                  ;
    }
    public static function test() {
    self::who()                                                                                                                                                                                                                                                 ;
    }
    public static function testStatic() {
    static::who()                                                                                                                                                                                                                                               ;
    }
    }
    class B extends A {
    public static function who() {
    print(__CLASS__) . PHP_EOL                                                                                                                                                                                                                                  ;
    }
    }
    B::test()                                                                                                                                                                                                                                                   ;
    B::testStatic()                                                                                                                                                                                                                                             ;
    // A
    // BМожет использоваться в проектировании паттернов в контексте наследования.

#### Как переопределить хранение сессий?
    В опции конфигурации session.save_handler .

#### Расскажите о SPL-библиотеке (Reflection, autoload, структуры данных).
    Стандартная библиотека PHP (SPL) - это набор интерфейсов и классов, предназначенных для решения стандартных задач.
    SPL предоставляет ряд стандартных структур данных, итераторов для оббегания объектов, интерфейсов, стандартных
    исключений, некоторое количество классов для работы с файлами и предоставляет ряд функций, например
    spl_autoload_register().
    Проще говоря, это сервисные классы php, которые предоставляют стандартизированные объекты для работы со
    структурами данных. Так же описывают стндарт загрузки библиотек. Что позволяет пользоваться сторонними
    модулями(библиотеками).

#### Расскажите о принципах SOLID.
    S: Single Responsibility Principle (Принцип единственной ответственности).
    O: Open-Closed Principle (Принцип открытости-закрытости).
    L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
    I: Interface Segregation Principle (Принцип разделения интерфейса).
    D: Dependency Inversion Principle (Принцип инверсии зависимостей).
    Note
    Здесь лучше всего описать своимим словами, так как понимаете именно вы. Еще желательно опыт применения. В
    каких случаях уместно.

#### Расскажите о шаблонах GRASP.GRASP — General Responsibility Assignment Software Patterns (основные шаблоны распределения обязанностей в
    программном обеспечении)
    GRASP состоит из 9 шаблонов:
    Creator
    Controller
    Pure Fabrication
    Information Expert
    High Cohesion
    Indirection
    Low Coupling
    Polymorphism
    Protected Variations

#### Расскажите о Dependency Injection: что такое DI-контейнеры? Какие есть варианты реализаций?
    Внедрение зависимостей — это когда один объект предоставляет зависимости другому объекту.
    Одним из ключевых моментов инверсии зависимостей является динамическое обеспечение объекта другими
    необходимыми ему объектами в системе. Это делается через DIC (контейнер внедрения зависимостей).
    declare(strict_types=1)                                                                                                                                                                                                                                     ;
    class DatabaseConfiguration
    {
    const HOST = 'localhost';
    const PORT = 80                                                                                                                                                                                                                                             ;
    const USERNAME = 'laravel';
    const PASSWORD = 'password';
    public function __construct(private string $host = self::HOST,
    private int $port = self::PORT,
    private string $username = self::USERNAME,
    private string $password = self::PASSWORD
    ) {
    }
    public function getHost(): string
    {
    return $this->host                                                                                                                                                                                                                                          ;
    }
    public function getPort(): int
    {
    return $this->port                                                                                                                                                                                                                                          ;
    }
    public function getUsername(): string
    {
    return $this->username                                                                                                                                                                                                                                      ;
    }
    public function getPassword(): string
    {
    return $this->password                                                                                                                                                                                                                                      ;
    }
    }
    class DatabaseConnection
    {
    public function __construct(private DatabaseConfiguration $configuration)
    {
    }public function getDsn(): string
    {
    return sprintf(
    '%s:%s@%s:%d',
    $this->configuration->getUsername(),
    $this->configuration->getPassword(),
    $this->configuration->getHost(),
    $this->configuration->getPort()
    )                                                                                                                                                                                                                                                           ;
    }
    }
    $dbConf = new DatabaseConfiguration()                                                                                                                                                                                                                       ;
    $dbConnect = new DatabaseConnection($dbConf)                                                                                                                                                                                                                ;
    echo $dbConnect->getDsn()                                                                                                                                                                                                                                   ;

#### Что вам известно о MVC?
    Model View Controller - архитектурный паттерн, который разделяет логику от модели и представления.

#### Что вам известно о шаблонах GoF?
    Паттерны "Банды 4" которые решают самые частые и повторяющийся проблемы проектирования архитектуры. Они есть
    трех видов:

* Порождающие
* Структурные
* Поведенческие

#### Что вам известно о шаблонах, которые применяются в ORM?
    Есть шаблон Active Record и Data Maper40. Напишите на PHP пример реализации паттерна Singleton.
    class Singleton
    {
    private static $instance = null                                                                                                                                                                                                                             ;
    private function __construct() {}
    /**

* @return Singleton
  */
  public static function getInstance()
  {
  if (self::$instance === null)
  {
  self::$instance = new self()                                                                                                                                                                                                                                ; 
  }
  return self::$instance                                                                                                                                                                                                                                      ; 
  }
  private function __clone() {}
  public function test()
  {
  var_dump($this)                                                                                                                                                                                                                                             ; 
  }
  }
  $Object = Singleton::getInstance()                                                                                                                                                                                                                          ; // Получение объекта
  //Вывод будет одинаковым, так как существует только один экземпляр
  $Object->test()                                                                                                                                                                                                                                             ; 
  Singleton::getInstance()->test()                                                                                                                                                                                                                            ; 
  // Попытка создать дополнительный экземпляр приведет к ошибке
  $Object2 = new Singleton()                                                                                                                                                                                                                                  ; // Fatal error: Call to private Singleton::__construct() from invalid context
  $Object3 = clone $Object                                                                                                                                                                                                                                    ; // Fatal error: Call to private Singleton::__clone() from context ''41. Что такое Docker? Каков принцип его работы?
  Docker — это платформа, которая позволяет упаковать в контейнер приложение со всем окружением и зависимостями, а
  затем доставить и запустить его в целевой системе. Приложение, упакованное в контейнер, изолируется от операционной
  системы и других приложений.

#### Расскажите о SSH-протоколе.
    SSH (от англ. secure shell ― безопасная оболочка) ― это защищённый сетевой протокол для удалённого управления
    сервером через интернет.
    Сетевой протокол прикладного уровня, предназначеный для безопасного удаленного доступа к UNIX-системам. Данный
    протокол эффективен тем, что шифрует всю передаваемую информацию по сети.

#### Что такое PDO?
    PDO (PHP Data Objects) — расширение PHP, которое реализует взаимодействие с базами данных при помощи объектов.
    Профит в том, что отсутствует привязка к конкретной системе управления базами данных

#### Что нового появилось в PHP 8?
    JIT компилятор
    Аннотации/Атрибуты (Attributes)
    Именованные параметры (Named Arguments)
    Оператор выбора match (Match expression v2)
    Адекватное приведение строки в число (Saner string to number comparisons)
    Constructor Property Promotion
    Объединения типов (Union Types 2.0)

#### В чем разница между GET и POST?Основное отличие метода GET от POST в способе передачи данных. Запрос GET передает данные в URL в виде пар "имя-
    значение" (другими словами, через ссылку), а запрос POST передает данные в теле запроса

#### Есть ли разница между одинарными и двойными кавычками?
    Строки с двойными и одинарными кавычками отличаются тем: Подстановкой переменных: в строку с двойными
    кавычками значение переменной подставляется, а в строчку с одинарными нет

#### Что такое Cookie и зачем они используются?
    Небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно
    веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-
    серверу в составе HTTP-запроса.

#### Что нельзя хранить в Cookie и почему?
    Конфеденциальные данные. Нельзя, потому что есть риск получить файл cookie злоумышленником.

### Принципы ООП и архетиктура

> Инкапсуляция. Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый
> набор функций

> Наследование. Возможность создания новых абстракций на основе существующих

> Полиморфизм. Возможность реализации наследуемых свойств или методов отличающимися способами в рамках
> множества абстракций

#### SOLID

> S: Single Responsibility Principle (Принцип единственной ответственности). обозначает, что каждый объект должен иметь одну обязанность и 
> эта обязанность должна быть полностью инкапсулирована в класс

> O: Open-Closed Principle (Принцип открытости-закрытости). Закрывать уже имеющийся функционал класса от изменения/удаления. 
> Но иметь возможность дополнять его при наследовании.

> L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков). Не изменяй функционал класса при наследовании а только дополняй его.

> I: Interface Segregation Principle (Принцип разделения интерфейса). Не создовай лишние методы одним интерфейсом - раздели его

> D: Dependency Inversion Principle (Принцип инверсии зависимостей). Классы верхнего уровня не должны зависеть от функционала 
> классов нижнего уровня(тех которые они используют). И те, и другие должны зависеть от абстракций(интерфейсов) а не наоборот. 

#### Хорошие практики написания кода

> DRY // Не повторяй один и тотже функционал, обёртывай его в отдельные методы
> KISS // Не усложняй всё гениальное просто
> YAGNI // не нагружай ненужным функционалом делай всё только то что необходимо

#### DI

> Внедрение зависимостей — это способ обработки зависимостей вне зависимого класса, когда зависимому классу не нужно ничего делать.
> (долгая телега но как пример внедрение зависимостей через construct в php)

#### Рекурсия

> Функция, которая вызывает саму себя

#### Патерны проектирования

> Повторяемая архитектурная конструкция в сфере проектирования программного обеспечения

#### Абстрактный класс

> тоже самое что и обычный, но может содержать абстрактные методы — методы без реализации, 
> и нельзя создать экземпляр абстрактного класса.


#### Интерфейс

> содержит определения функций (то есть описание их сигнатур) без их реализации. (и ещё свойства из него можно использовать удачно)

#### Namespace

> Namespace - это механизм использование класса через пространство имен (не то что эти ваши Import в JS)

#### Плюсы и минусы динамической системы типов данных.

> Плюсы: в быстрой разработке и прототипировании. Минусы: наличие ошибок и утяжеление дебаггинга.

#### Сложность алгоритма?

> Это количественная характеристика, которая говорит о том, сколько времени, либо какой объём
> памяти потребуется для выполнения алгоритма. О(n) - обозначается как О большое.

#### оператор yield?

> В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо
> прекращения работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при
> следующем вызове функции она возобновит выполнение с места, на котором прервалась.

#### В чем разница между =, == и === ?

> = - оператор присвоения

> == - оператор определяет нестрогое сравнение

> === - оператор строгого сравнение. Эквивалентное сравнение (типы переменных и их значения должны строго совпадать)

#### Инкрименнт - декримент / префиксный - постфиксный

> Декремент - увеличивает значение переменной на единицу

> Инкремент - уменьшает значение переменной на единицу

> При использовании префиксной нотации сначала происходит изменение переменной, а потом — возврат. При
> использовании постфиксной нотации — наоборот: сначала возврат, а потом изменение переменной.

#### Паттерны проектирования

> Facade - структурный паттерн проектирования, позволяющий скрыть сложность системы путём сведения всех возможных 
> внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

> Builder -  порождающий паттерн проектирования предоставляет способ создания составного объекта.

> Fabrica - порождающий паттерн проектирования, предоставляющий подклассам (дочерним классам, субклассам) 
> интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. 
> Иными словами, данный паттерн делегирует создание объектов наследникам родительского класса. 
> Это позволяет использовать в коде программы не конкретные классы, а манипулировать абстрактными объектами на более высоком уровне

> Bridge -  структурный паттерн проектирования, используемый в проектировании программного обеспечения, 
> чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо». Шаблон мост использует инкапсуляцию, 
> агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

> Abstract Fabrica - это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, 
> не привязываясь к конкретным классам создаваемых объектов

#### Простая фабрика

> Класс по созданию нужных нам объектов. Простая фабрика просто генерирует экземпляр для клиента без предоставления
> какой-либо логики экземпляра.

#### Service Layer

> Шаблон проектирования, который инкапсулирует бизнес логику вашего приложения и определяет границу и набор
> допустимых операций с точки зрения взаимодействующих с ним клиентов.

#### Mock

> Mock-объект представляет собой конкретную фиктивную реализацию интерфейса, предназначенную исключительно для
> тестирования взаимодействия и относительно которого высказывается утверждение.

> Например - тест входных данных из удалённого приложения может потребовать Mock в тестировании чтобы не выводилось ошибок при использовании базового класса

#### Хэш-функция

> Функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку
> установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, 
> называется хешированием.

#### Позднее статическое связывание?

> Вызов метода в контексте текущего класса

#### Структуры данных

> Arrays (массивы) Каждому элементу данных присваивается положительное числовое значение, называемое индексом, 
> которое соответствует позиции этого элемента в массиве

> Stacks (стеки) Undo Суть механизма в том, что вы сохраняете предыдущие состояния вашей работы (которые ограничены определенным числом) 
> в памяти в таком порядке, что последнее действие появляется первым. Это не может быть сделано только с помощью массивов

> Queues (очереди) Как стэк только при добавлении элемента он встаёт в конец а при удалении забирается из начала

> Lists (списки) Как масивы только данные хранятся в памяти не общей ячейкой а по раздельности и 
> каждый элемент указывает на последущий элемент (быстрее запись медленнее поиск если сравнивать с масивами)

> Graphs (графы) цикличная сеть с вершинами и гранями удобно вычеслять расстояние между вершинами используется для быстрого сравнения 
> ( работа с картами, Программное эмулирование электрических цепей, поисковые алгоритмы, распределение )

> Trees (деревья) разорваные графы с ирархией удобно использовать для сравнения и нахождения оптимального значения

> Tries (очередности) древовидную структуру данных, которая оказывается достаточно эффективной для решения проблем, 
> связанных со строками. Они обеспечивают быстрый поиск и, в основном, используются для поиска слов в словаре, 
> автоматического предложения в поисковой системе и даже для IP-маршрутизации.

> Hash Tables (хэш таблицы) Хеширование — это процесс, используемый для уникальной идентификации объектов и 
> сохранения каждого объекта по некоторому предварительно рассчитанному уникальному индексу, называемому его «ключом». 
> Таким образом, объект хранится в форме пары «ключ-значение», а коллекция таких элементов называется «словарь». 
> Каждый объект может быть найден с помощью этого ключа. пример -> гит коммиты

#### OOP

ооп это ооп

#### Принципы ООП

> Инкапсуляция. Скрытие внутреннего состояния и функций объекта и предоставление доступа только через открытый
> набор функций

> Наследование. Возможность создания новых абстракций на основе существующих

> Полиморфизм. Возможность реализации наследуемых свойств или методов отличающимися способами в рамках
> множества абстракций

#### Абстрактный класс

 

> тоже самое что и обычный, но отличается тем, что может содержать абстрактные методы — методы без реализации, 
> и нельзя создать экземпляр абстрактного класса.

#### Интерфейс

> содержит определения функций (то есть описание их сигнатур) без их реализации. (не в пхп ещё и описание свойств)

#### SOLID

> S: Single Responsibility Principle (Принцип единственной ответственности). обозначает, что каждый объект должен иметь одну обязанность и 
> эта обязанность должна быть полностью инкапсулирована в класс

> O: Open-Closed Principle (Принцип открытости-закрытости). Закрывать уже имеющийся функционал класса от изменения/удаления. 
> Но иметь возможность дополнять его при наследовании.

> L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков). Не изменяй функционал класса при наследовании а только дополняй его.

> I: Interface Segregation Principle (Принцип разделения интерфейса). Не создовай лишние методы одним интерфейсом - раздели его

> D: Dependency Inversion Principle (Принцип инверсии зависимостей). Классы верхнего уровня не должны зависеть от функционала 
> классов нижнего уровня(тех которые они используют). И те, и другие должны зависеть от абстракций(интерфейсов) а не наоборот. 

#### Namespace

> Namespace - это механизм использование класса через пространство имен

#### Плюсы и минусы динамической системы типов данных.

> Плюсы: в быстрой разработке и прототипировании. Минусы: наличие ошибок и утяжеление дебаггинга.

#### Сложность алгоритма?

> Это количественная характеристика, которая говорит о том, сколько времени, либо какой объём
> памяти потребуется для выполнения алгоритма. О(n) - обозначается как О большое.

#### Рекурсия

> Функция, которая вызывает саму себя

#### оператор yield?

> В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо
> прекращения работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при
> следующем вызове функции она возобновит выполнение с места, на котором прервалась.

#### В чем разница между =, == и === ?

> = - оператор присвоения

> == - оператор определяет нестрогое сравнение

> === - оператор строгого сравнение. Эквивалентное сравнение (типы переменных и их значения должны строго совпадать)

#### Инкрименнт - декримент / префиксный - постфиксный

> Декремент - увеличивает значение переменной на единицу

> Инкремент - уменьшает значение переменной на единицу

> При использовании префиксной нотации сначала происходит изменение переменной, а потом — возврат. При
> использовании постфиксной нотации — наоборот: сначала возврат, а потом изменение переменной.

#### Что такое SOLID, DRY, KISS, YAGNI?

> Хорошие практики написания кода

#### Паттерны проектирования

> Facade

> Builder

> Fabrica

> Bridge

> Abstract Fabrica

#### Простая фабрика

> Класс по созданию нужных нам объектов. Простая фабрика просто генерирует экземпляр для клиента без предоставления
> какой-либо логики экземпляра.

#### Service Layer

> Шаблон проектирования, который инкапсулирует бизнес логику вашего приложения и определяет границу и набор
> допустимых операций с точки зрения взаимодействующих с ним клиентов.

#### Mock

> Mock-объект представляет собой конкретную фиктивную реализацию интерфейса, предназначенную исключительно для
> тестирования взаимодействия и относительно которого высказывается утверждение.

#### Хэш-функция

> Функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку
> установленной длины, выполняемое определённым алгоритмом. Преобразование, производимое хеш-функцией, 
> называется хешированием.

#### Позднее статическое связывание?

> Вызов метода в контексте текущего класса

#### Структуры данных

> Arrays (массивы) Каждому элементу данных присваивается положительное числовое значение, называемое индексом, 
> которое соответствует позиции этого элемента в массиве

> Stacks (стеки) Undo Суть механизма в том, что вы сохраняете предыдущие состояния вашей работы (которые ограничены определенным числом) 
> в памяти в таком порядке, что последнее действие появляется первым. Это не может быть сделано только с помощью массивов

> Queues (очереди) Как стэк только при добавлении элемента он встаёт в конец а при удалении забирается из начала

> Lists (списки) Как масивы только данные хранятся в памяти не общей ячейкой а по раздельности и 
> каждый элемент указывает на последущий элемент (быстрее запись медленнее поиск если сравнивать с масивами)

> Graphs (графы) цикличная сеть с вершинами и гранями удобно вычеслять расстояние между вершинами используется для быстрого сравнения 
> ( работа с картами, Программное эмулирование электрических цепей, поисковые алгоритмы, распределение )

> Trees (деревья) разорваные графы с ирархией удобно использовать для сравнения и нахождения оптимального значения

> Tries (очередности) древовидную структуру данных, которая оказывается достаточно эффективной для решения проблем, 
> связанных со строками. Они обеспечивают быстрый поиск и, в основном, используются для поиска слов в словаре, 
> автоматического предложения в поисковой системе и даже для IP-маршрутизации.

> Hash Tables (хэш таблицы) Хеширование — это процесс, используемый для уникальной идентификации объектов и 
> сохранения каждого объекта по некоторому предварительно рассчитанному уникальному индексу, называемому его «ключом». 
> Таким образом, объект хранится в форме пары «ключ-значение», а коллекция таких элементов называется «словарь». 
> Каждый объект может быть найден с помощью этого ключа. пример -> гит коммиты
